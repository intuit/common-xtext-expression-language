{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Common-Expression-Language \u00b6 The project provides an expression language built using Xtext and a runtime engine to evaluate the expressions. The expression grammar can be imported in other Xtext DSLs to create composable and reusable languages using Xtext. Usage \u00b6 Add the maven dependency <groupId> com.intuit.dsl.expression </groupId> <artifactId> com.intuit.dsl.expression.runtime </artifactId> <version> ${latest} </version> Code usage DataValue value = ExpressionRuntime . newExpressionRuntime () . withExpressionContent ( expressionString ) . evaluate (); Setting up the Project \u00b6 Pre-requisites \u00b6 Java 8 Maven 3 Making changes to Runtime \u00b6 Clone common-xtext-expression-language Run maven clean install Import the runtime module com.intuit.dsl.expression.runtime . This is standard java project which can be imported in your favorite editor. Making changes to Expression Grammar \u00b6 Download and install Eclipse MAC / Windows / Linux . Install Xtext SDK in Eclipse: a. In Eclipse, click Help \u2192 Install New Software. b. In Available Software, click Add to add a repository with the following location http://download.eclipse.org/modeling/tmf/xtext/updates/composite/releases/ c. Select the repository just added in 'Work with' dropdown. d. Select and install Xtext Complete SDK. Restart Eclipse. Edit the grammar Right click on GenerateExpression.mwe2 . Run As \u2192 1 MWE2 Workflow. OR mvn clean install inside the project You should be able to use the grammar changes in your runtime. Formatting \u00b6 Read the Contribution guide","title":"Home"},{"location":"#common-expression-language","text":"The project provides an expression language built using Xtext and a runtime engine to evaluate the expressions. The expression grammar can be imported in other Xtext DSLs to create composable and reusable languages using Xtext.","title":"Common-Expression-Language"},{"location":"#usage","text":"Add the maven dependency <groupId> com.intuit.dsl.expression </groupId> <artifactId> com.intuit.dsl.expression.runtime </artifactId> <version> ${latest} </version> Code usage DataValue value = ExpressionRuntime . newExpressionRuntime () . withExpressionContent ( expressionString ) . evaluate ();","title":"Usage"},{"location":"#setting-up-the-project","text":"","title":"Setting up the Project"},{"location":"#pre-requisites","text":"Java 8 Maven 3","title":"Pre-requisites"},{"location":"#making-changes-to-runtime","text":"Clone common-xtext-expression-language Run maven clean install Import the runtime module com.intuit.dsl.expression.runtime . This is standard java project which can be imported in your favorite editor.","title":"Making changes to Runtime"},{"location":"#making-changes-to-expression-grammar","text":"Download and install Eclipse MAC / Windows / Linux . Install Xtext SDK in Eclipse: a. In Eclipse, click Help \u2192 Install New Software. b. In Available Software, click Add to add a repository with the following location http://download.eclipse.org/modeling/tmf/xtext/updates/composite/releases/ c. Select the repository just added in 'Work with' dropdown. d. Select and install Xtext Complete SDK. Restart Eclipse. Edit the grammar Right click on GenerateExpression.mwe2 . Run As \u2192 1 MWE2 Workflow. OR mvn clean install inside the project You should be able to use the grammar changes in your runtime.","title":"Making changes to Expression Grammar"},{"location":"#formatting","text":"Read the Contribution guide","title":"Formatting"},{"location":"expressions/Arithmetic/","text":"Supported arithmetic operations in expressions are as follow: * Plus (+) * Minus (-) * Multiplicationn (*) * Division (/) * Mod (%) Example \u00b6 Schema numbersSchema { number num1 number num2 } value numbers -> numbersSchema { 1 2 } Schema outputSchema { number plusOp number minusOp number multOp number divOp number modOp } Mapping arithmeticMapping input numbers as numbers output outputSchema { outputSchema . plusOp = numbers . num1 + numbers . num2 outputSchema . minusOp = numbers . num2 - numbers . num1 outputSchema . multOp = numbers . num1 * numbers . num2 outputSchema . divOp = numbers . num1 / numbers . num2 outputSchema . modOp = numbers . num1 % numbers . num2 } Output for Example Flow \u00b6 { \"plusOp\": 3, \"minusOp\": 1, \"multOp\": 2, \"divOp\": 0.5, \"modOp\": 1 }","title":"Arithmetic"},{"location":"expressions/Arithmetic/#example","text":"Schema numbersSchema { number num1 number num2 } value numbers -> numbersSchema { 1 2 } Schema outputSchema { number plusOp number minusOp number multOp number divOp number modOp } Mapping arithmeticMapping input numbers as numbers output outputSchema { outputSchema . plusOp = numbers . num1 + numbers . num2 outputSchema . minusOp = numbers . num2 - numbers . num1 outputSchema . multOp = numbers . num1 * numbers . num2 outputSchema . divOp = numbers . num1 / numbers . num2 outputSchema . modOp = numbers . num1 % numbers . num2 }","title":"Example"},{"location":"expressions/Arithmetic/#output-for-example-flow","text":"{ \"plusOp\": 3, \"minusOp\": 1, \"multOp\": 2, \"divOp\": 0.5, \"modOp\": 1 }","title":"Output for Example Flow"},{"location":"expressions/Boolean/","text":"Supported boolean operations in expressions are as follow: * AND (&&) * OR (||) * NOT (!) Example \u00b6 Schema booleanSchema { boolean truthValue boolean falseValue } value booleans -> booleanSchema { true false } Schema outputSchema { boolean andTT boolean andTF boolean andFT boolean andFF boolean orTT boolean orTF boolean orFT boolean orFF boolean notF boolean notT } Mapping booleanMapping input booleans as booleans output outputSchema { outputSchema . andTT = booleans . truthValue && booleans . truthValue outputSchema . andTF = booleans . truthValue && booleans . falseValue outputSchema . andFT = booleans . falseValue && booleans . truthValue outputSchema . andFF = booleans . falseValue && booleans . falseValue outputSchema . orTT = booleans . truthValue || booleans . truthValue outputSchema . orTF = booleans . truthValue || booleans . falseValue outputSchema . orFT = booleans . falseValue || booleans . truthValue outputSchema . orFF = booleans . falseValue || booleans . falseValue outputSchema . notF = ! booleans . falseValue outputSchema . notT = ! booleans . truthValue } Output for Example Flow \u00b6 { \"andTT\": true, \"andTF\": false, \"andFT\": false, \"andFF\": false, \"orTT\": true, \"orTF\": true, \"orFT\": true, \"orFF\": false, \"notF\": true, \"notT\": false }","title":"Boolean"},{"location":"expressions/Boolean/#example","text":"Schema booleanSchema { boolean truthValue boolean falseValue } value booleans -> booleanSchema { true false } Schema outputSchema { boolean andTT boolean andTF boolean andFT boolean andFF boolean orTT boolean orTF boolean orFT boolean orFF boolean notF boolean notT } Mapping booleanMapping input booleans as booleans output outputSchema { outputSchema . andTT = booleans . truthValue && booleans . truthValue outputSchema . andTF = booleans . truthValue && booleans . falseValue outputSchema . andFT = booleans . falseValue && booleans . truthValue outputSchema . andFF = booleans . falseValue && booleans . falseValue outputSchema . orTT = booleans . truthValue || booleans . truthValue outputSchema . orTF = booleans . truthValue || booleans . falseValue outputSchema . orFT = booleans . falseValue || booleans . truthValue outputSchema . orFF = booleans . falseValue || booleans . falseValue outputSchema . notF = ! booleans . falseValue outputSchema . notT = ! booleans . truthValue }","title":"Example"},{"location":"expressions/Boolean/#output-for-example-flow","text":"{ \"andTT\": true, \"andTF\": false, \"andFT\": false, \"andFF\": false, \"orTT\": true, \"orTF\": true, \"orFT\": true, \"orFF\": false, \"notF\": true, \"notT\": false }","title":"Output for Example Flow"},{"location":"expressions/Conditional/","text":"Supported conditionals in expressions are: * Less than (<) * Greater than (>) * Less than equal to (<=) * Greater than equal to (>=) * Equal to (==) * Not equal to (!=) * Fuzzy Equals (=~) (currently works only for strings with different case and numbers) * Fuzzy not (!~) (currently works only for strings with different case and numbers) * Ternary expression: Syntax : if [expression] then [trueValue] else [falseValue] Example \u00b6 Schema dataSchema { number zero number ten string lowerCaseOne } value data -> dataSchema { 0 10 \"one\" } Schema outputSchema { boolean lt boolean gt boolean ltet boolean gtet boolean eq boolean neq boolean feqNumber boolean feqString boolean fneqNumber boolean fneqString string ternaryEx } Mapping conditionalMapping input data as data output outputSchema { outputSchema . lt = data . zero < data . ten outputSchema . gt = data . zero > data . ten outputSchema . ltet = data . zero <= data . ten outputSchema . gtet = data . zero >= data . ten outputSchema . eq = data . zero == data . ten outputSchema . neq = data . zero != data . ten outputSchema . feqNumber = data . zero =~ data . zero outputSchema . feqString = data . lowerCaseOne =~ \"ONE\" outputSchema . fneqNumber = data . zero !~ data . ten outputSchema . fneqString = data . lowerCaseOne !~ \"ONES\" outputSchema . ternaryEx = if ( data . zero >= data . ten ) then ( data . zero * data . ten ) else ( data . zero + data . ten ) } Output for Example Flow \u00b6 { \"lt\": true, \"gt\": false, \"ltet\": true, \"gtet\": false, \"eq\": false, \"neq\": true, \"feqNumber\": true, \"feqString\": true, \"fneqNumber\": true, \"fneqString\": true, \"ternaryEx\": \"10\" }","title":"Conditional"},{"location":"expressions/Conditional/#example","text":"Schema dataSchema { number zero number ten string lowerCaseOne } value data -> dataSchema { 0 10 \"one\" } Schema outputSchema { boolean lt boolean gt boolean ltet boolean gtet boolean eq boolean neq boolean feqNumber boolean feqString boolean fneqNumber boolean fneqString string ternaryEx } Mapping conditionalMapping input data as data output outputSchema { outputSchema . lt = data . zero < data . ten outputSchema . gt = data . zero > data . ten outputSchema . ltet = data . zero <= data . ten outputSchema . gtet = data . zero >= data . ten outputSchema . eq = data . zero == data . ten outputSchema . neq = data . zero != data . ten outputSchema . feqNumber = data . zero =~ data . zero outputSchema . feqString = data . lowerCaseOne =~ \"ONE\" outputSchema . fneqNumber = data . zero !~ data . ten outputSchema . fneqString = data . lowerCaseOne !~ \"ONES\" outputSchema . ternaryEx = if ( data . zero >= data . ten ) then ( data . zero * data . ten ) else ( data . zero + data . ten ) }","title":"Example"},{"location":"expressions/Conditional/#output-for-example-flow","text":"{ \"lt\": true, \"gt\": false, \"ltet\": true, \"gtet\": false, \"eq\": false, \"neq\": true, \"feqNumber\": true, \"feqString\": true, \"fneqNumber\": true, \"fneqString\": true, \"ternaryEx\": \"10\" }","title":"Output for Example Flow"},{"location":"functions/concat/","text":"The concat function concats two or more objects and gives an object back. Syntax \u00b6 output = concat(expression, expression) Inputs \u00b6 expression : a reference to a variable or any [[expression|Expressions]]. Output \u00b6 output : a concatenated object from input. Example flow \u00b6 Schema input1 { string a b [ string c ] d { string e } } Schema input2 { string p q [ string r ] s { string t } } Schema concatOutput { string result1 result2 [ string op ] string result3 string result4 result5 [ string op ] string result6 } value inputValue1 -> input1 { \"hello\" b [{ \"12345\" }] d { \"V1-120-a3qteenpmrvmjzjm45hrlr\" } } value inputValue2 -> input2 { \"world\" q [{ \"V1-120-a3qteenpmrvmjzjm45hrlr\" }] s { \"12345\" } } Mapping concatMapping input inputValue1 as x , inputValue2 as y output concatOutput as op { op . result1 = concat ( x . a , y . p ) op . result2 = concat ( x . b , y . q ) op . result3 = concat ( x . d . e , y . s . t ) op . result4 = concat ( \"\" , null ) op . result5 = concat ( x . b , null ) op . result6 = concat ( null , null ) } Output for Example Flow \u00b6 { \"result1\": \"helloworld\", \"result2\": [ { \"c\": \"12345\" }, { \"r\": \"V1-120-a3qteenpmrvmjzjm45hrlr\" } ], \"result3\": \"V1-120-a3qteenpmrvmjzjm45hrlr12345\", \"result4\": \"\", \"result5\": [ { \"c\": \"12345\" } ], \"result6\": null }","title":"Concat"},{"location":"functions/concat/#syntax","text":"output = concat(expression, expression)","title":"Syntax"},{"location":"functions/concat/#inputs","text":"expression : a reference to a variable or any [[expression|Expressions]].","title":"Inputs"},{"location":"functions/concat/#output","text":"output : a concatenated object from input.","title":"Output"},{"location":"functions/concat/#example-flow","text":"Schema input1 { string a b [ string c ] d { string e } } Schema input2 { string p q [ string r ] s { string t } } Schema concatOutput { string result1 result2 [ string op ] string result3 string result4 result5 [ string op ] string result6 } value inputValue1 -> input1 { \"hello\" b [{ \"12345\" }] d { \"V1-120-a3qteenpmrvmjzjm45hrlr\" } } value inputValue2 -> input2 { \"world\" q [{ \"V1-120-a3qteenpmrvmjzjm45hrlr\" }] s { \"12345\" } } Mapping concatMapping input inputValue1 as x , inputValue2 as y output concatOutput as op { op . result1 = concat ( x . a , y . p ) op . result2 = concat ( x . b , y . q ) op . result3 = concat ( x . d . e , y . s . t ) op . result4 = concat ( \"\" , null ) op . result5 = concat ( x . b , null ) op . result6 = concat ( null , null ) }","title":"Example flow"},{"location":"functions/concat/#output-for-example-flow","text":"{ \"result1\": \"helloworld\", \"result2\": [ { \"c\": \"12345\" }, { \"r\": \"V1-120-a3qteenpmrvmjzjm45hrlr\" } ], \"result3\": \"V1-120-a3qteenpmrvmjzjm45hrlr12345\", \"result4\": \"\", \"result5\": [ { \"c\": \"12345\" } ], \"result6\": null }","title":"Output for Example Flow"},{"location":"functions/contains/","text":"Given a string or a number, contains function will check for a specified substring in it. Syntax \u00b6 output = contains(expression, searchText) Inputs \u00b6 expression : a reference to a variable or any [[expression|Expressions]]. searchText : A substring or a number to search from input expression value. Output \u00b6 output : A boolean depending on if substring is found or not in the input expression value. Example flow \u00b6 Schema splitWordSchema { boolean containsInString boolean containsInNumber boolean containsStringNum boolean containsNumString } Schema wordSchema { string recipes string strNum number num } value dummyWord -> wordSchema { \"GTKM=B&RTP=B\" \"GTKM=B&RTP=B89\" 8766756 } Mapping containsMapping input dummyWord as dummyWord output splitWordSchema { splitWordSchema . containsInString = contains ( dummyWord . recipes , \"RTP=B\" ) splitWordSchema . containsInNumber = contains ( dummyWord . num , 7 ) splitWordSchema . containsStringNum = contains ( dummyWord . num , \"7\" ) splitWordSchema . containsNumString = contains ( dummyWord . strNum , \"8\" ) } Output for Example Flow \u00b6 { \"containsInString\": true, \"containsInNumber\": true, \"containsStringNum\": true, \"containsNumString\": true }","title":"Contains"},{"location":"functions/contains/#syntax","text":"output = contains(expression, searchText)","title":"Syntax"},{"location":"functions/contains/#inputs","text":"expression : a reference to a variable or any [[expression|Expressions]]. searchText : A substring or a number to search from input expression value.","title":"Inputs"},{"location":"functions/contains/#output","text":"output : A boolean depending on if substring is found or not in the input expression value.","title":"Output"},{"location":"functions/contains/#example-flow","text":"Schema splitWordSchema { boolean containsInString boolean containsInNumber boolean containsStringNum boolean containsNumString } Schema wordSchema { string recipes string strNum number num } value dummyWord -> wordSchema { \"GTKM=B&RTP=B\" \"GTKM=B&RTP=B89\" 8766756 } Mapping containsMapping input dummyWord as dummyWord output splitWordSchema { splitWordSchema . containsInString = contains ( dummyWord . recipes , \"RTP=B\" ) splitWordSchema . containsInNumber = contains ( dummyWord . num , 7 ) splitWordSchema . containsStringNum = contains ( dummyWord . num , \"7\" ) splitWordSchema . containsNumString = contains ( dummyWord . strNum , \"8\" ) }","title":"Example flow"},{"location":"functions/contains/#output-for-example-flow","text":"{ \"containsInString\": true, \"containsInNumber\": true, \"containsStringNum\": true, \"containsNumString\": true }","title":"Output for Example Flow"},{"location":"functions/currentDate/","text":"Syntax \u00b6 currentDate () will return date in mm / dd / yyyy format currentDate ( dateFormat ) where dateFormat is any valid SimpleDateFormat will return date in that format currentDate ( ' ms ' ) will return date in milliseconds . Notice they ' re single quotes, not double quotes. Output \u00b6 11/09/2018 03:35:38 1541806538347","title":"CurrentDate"},{"location":"functions/currentDate/#syntax","text":"currentDate () will return date in mm / dd / yyyy format currentDate ( dateFormat ) where dateFormat is any valid SimpleDateFormat will return date in that format currentDate ( ' ms ' ) will return date in milliseconds . Notice they ' re single quotes, not double quotes.","title":"Syntax"},{"location":"functions/currentDate/#output","text":"11/09/2018 03:35:38 1541806538347","title":"Output"},{"location":"functions/dateFormat/","text":"Syntax \u00b6 dateFormat(inputFormat, outputFormat, expression, inputTimeZone, outputTimeZone) inputFormat : Input format can be any input from the following pre defined formats. outputFormat : Output format can be any input from the following pre defined formats. Input/ Output Formats \u00b6 MM/dd/yyyy yyyyMMdd yyyy-MM-dd yyyy-MM-dd'T'HH:mm:ssZ ms - miliseconds (representing epoch time) expression : Expression is the value of date which needs to be converted. inputTimeZone : Input TimeZone. It is an optional parameter. The default value is V4OS system timezone. If you are at west, it will be PST. If you are at east, it will be EST. The ID for a TimeZone, either an abbreviation such as \"PST\", a full name such as \"America/Los_Angeles\", or a custom ID such as \"GMT-8:00\". See details here outputTimeZone : Output TimeZone. It is an optional parameter. It is an optional parameter. The default value is V4OS system timezone. If you are at west, it will be PST. If you are at east, it will be EST. The ID for a TimeZone, either an abbreviation such as \"PST\", a full name such as \"America/Los_Angeles\", or a custom ID such as \"GMT-8:00\". See details here Example Flow \u00b6 Schema datesSchema { string MMddyyyy_slash string yyyyMMdd string yyyyMMdd_hyphen number msNumber string msString string fromTimeZone string toTimeZone } Schema formatedDates { string date1 string date2 string date3 string date4 number date5 string date6 string date7 string date8 string date9 string date10 string date11 string date12 string date13 string date14 } value dates -> datesSchema { \"02/20/1991\" \"19910220\" \"1991-02-20\" 94670856000 \"667036800000\" \"UTC\" \"GMT-0400\" } Mapping dateFormatMapping input dates as dates output formatedDates as formatedDates { formatedDates . date1 = dateFormat ( \"MM/dd/yyyy\" , \"yyyyMMdd\" , dates . MMddyyyy_slash ) formatedDates . date2 = dateFormat ( \"yyyyMMdd\" , \"yyyy-MM-dd\" , dates . yyyyMMdd ) formatedDates . date3 = dateFormat ( \"yyyy-MM-dd\" , \"MM/dd/yyyy\" , dates . yyyyMMdd_hyphen ) formatedDates . date4 = dateFormat ( \"MM/dd/yyyy\" , \"ms\" , dates . MMddyyyy_slash ) formatedDates . date5 = dateFormat ( \"MM/dd/yyyy\" , \"ms\" , dates . MMddyyyy_slash ) + dates . msNumber formatedDates . date6 = dateFormat ( \"ms\" , \"MM/dd/yyyy\" , dates . msString ) formatedDates . date7 = dateFormat ( \"ms\" , \"yyyyMMdd\" , dates . msString ) formatedDates . date8 = dateFormat ( \"ms\" , \"yyyy-MM-dd\" , dates . msString ) formatedDates . date9 = dateFormat ( \"MM/dd/yyyy\" , \"MM/dd/yyyy\" , dates . MMddyyyy_slash ) formatedDates . date10 = dateFormat ( \"yyyyMMdd\" , \"yyyyMMdd\" , dates . yyyyMMdd ) formatedDates . date11 = dateFormat ( \"yyyy-MM-dd\" , \"yyyy-MM-dd\" , dates . yyyyMMdd_hyphen ) formatedDates . date12 = dateFormat ( \"ms\" , \"ms\" , dates . msString ) formatedDates . date13 = dateFormat ( \"yyyyMMdd\" , \"yyyy-MM-dd\" , dates . MMddyyyy_slash ) formatedDates . date14 = dateFormat ( \"ms\" , \"yyyy-MM-dd' T 'HH:mm:ssZ\" , \"1630624704000\" , dates . fromTimeZone , dates . toTimeZone ) } End end Flow dateFormatFlow { Start dateFormatMapping { transition { true ? end : end } } end {} } Example Output \u00b6 { \"date1\": \"19910220\", \"date2\": \"1991-02-20\", \"date3\": \"02/20/1991\", \"date4\": \"667036800000\", \"date5\": 761707656000, \"date6\": \"02/20/1991\", \"date7\": \"19910220\", \"date8\": \"1991-02-20\", \"date9\": \"02/20/1991\", \"date10\": \"19910220\", \"date11\": \"1991-02-20\", \"date12\": \"667036800000\", \"date13\": \"02/20/1991\", \"date14\": \"2021-09-02T19:18:24-0400\", }","title":"DateFormat"},{"location":"functions/dateFormat/#syntax","text":"dateFormat(inputFormat, outputFormat, expression, inputTimeZone, outputTimeZone) inputFormat : Input format can be any input from the following pre defined formats. outputFormat : Output format can be any input from the following pre defined formats.","title":"Syntax"},{"location":"functions/dateFormat/#input-output-formats","text":"MM/dd/yyyy yyyyMMdd yyyy-MM-dd yyyy-MM-dd'T'HH:mm:ssZ ms - miliseconds (representing epoch time) expression : Expression is the value of date which needs to be converted. inputTimeZone : Input TimeZone. It is an optional parameter. The default value is V4OS system timezone. If you are at west, it will be PST. If you are at east, it will be EST. The ID for a TimeZone, either an abbreviation such as \"PST\", a full name such as \"America/Los_Angeles\", or a custom ID such as \"GMT-8:00\". See details here outputTimeZone : Output TimeZone. It is an optional parameter. It is an optional parameter. The default value is V4OS system timezone. If you are at west, it will be PST. If you are at east, it will be EST. The ID for a TimeZone, either an abbreviation such as \"PST\", a full name such as \"America/Los_Angeles\", or a custom ID such as \"GMT-8:00\". See details here","title":"Input/ Output Formats"},{"location":"functions/dateFormat/#example-flow","text":"Schema datesSchema { string MMddyyyy_slash string yyyyMMdd string yyyyMMdd_hyphen number msNumber string msString string fromTimeZone string toTimeZone } Schema formatedDates { string date1 string date2 string date3 string date4 number date5 string date6 string date7 string date8 string date9 string date10 string date11 string date12 string date13 string date14 } value dates -> datesSchema { \"02/20/1991\" \"19910220\" \"1991-02-20\" 94670856000 \"667036800000\" \"UTC\" \"GMT-0400\" } Mapping dateFormatMapping input dates as dates output formatedDates as formatedDates { formatedDates . date1 = dateFormat ( \"MM/dd/yyyy\" , \"yyyyMMdd\" , dates . MMddyyyy_slash ) formatedDates . date2 = dateFormat ( \"yyyyMMdd\" , \"yyyy-MM-dd\" , dates . yyyyMMdd ) formatedDates . date3 = dateFormat ( \"yyyy-MM-dd\" , \"MM/dd/yyyy\" , dates . yyyyMMdd_hyphen ) formatedDates . date4 = dateFormat ( \"MM/dd/yyyy\" , \"ms\" , dates . MMddyyyy_slash ) formatedDates . date5 = dateFormat ( \"MM/dd/yyyy\" , \"ms\" , dates . MMddyyyy_slash ) + dates . msNumber formatedDates . date6 = dateFormat ( \"ms\" , \"MM/dd/yyyy\" , dates . msString ) formatedDates . date7 = dateFormat ( \"ms\" , \"yyyyMMdd\" , dates . msString ) formatedDates . date8 = dateFormat ( \"ms\" , \"yyyy-MM-dd\" , dates . msString ) formatedDates . date9 = dateFormat ( \"MM/dd/yyyy\" , \"MM/dd/yyyy\" , dates . MMddyyyy_slash ) formatedDates . date10 = dateFormat ( \"yyyyMMdd\" , \"yyyyMMdd\" , dates . yyyyMMdd ) formatedDates . date11 = dateFormat ( \"yyyy-MM-dd\" , \"yyyy-MM-dd\" , dates . yyyyMMdd_hyphen ) formatedDates . date12 = dateFormat ( \"ms\" , \"ms\" , dates . msString ) formatedDates . date13 = dateFormat ( \"yyyyMMdd\" , \"yyyy-MM-dd\" , dates . MMddyyyy_slash ) formatedDates . date14 = dateFormat ( \"ms\" , \"yyyy-MM-dd' T 'HH:mm:ssZ\" , \"1630624704000\" , dates . fromTimeZone , dates . toTimeZone ) } End end Flow dateFormatFlow { Start dateFormatMapping { transition { true ? end : end } } end {} }","title":"Example Flow"},{"location":"functions/dateFormat/#example-output","text":"{ \"date1\": \"19910220\", \"date2\": \"1991-02-20\", \"date3\": \"02/20/1991\", \"date4\": \"667036800000\", \"date5\": 761707656000, \"date6\": \"02/20/1991\", \"date7\": \"19910220\", \"date8\": \"1991-02-20\", \"date9\": \"02/20/1991\", \"date10\": \"19910220\", \"date11\": \"1991-02-20\", \"date12\": \"667036800000\", \"date13\": \"02/20/1991\", \"date14\": \"2021-09-02T19:18:24-0400\", }","title":"Example Output"},{"location":"functions/dayDifference/","text":"Syntax \u00b6 dayDifference(input1, input2, format) input1 : Value of Date form which you want to subtract. input2 : Value of Date to be subtracted. format : Format can be any input from the following pre defined formats but both the inputs need to be in same format. Formats \u00b6 MM/dd/yyyy yyyyMMdd yyyy-MM-dd Example Flow \u00b6 Schema dummy1 { string a string b string c string d } Schema dummy2 { string p string q string r string s } Schema dummyOutput { number result1 number result2 number result3 number result4 number result5 number result6 } value dummyValue1 -> dummy1 { \"10/16/1990\" \"10/16/2018\" \"20161209\" \"2000-11-2\" } value dummyValue2 -> dummy2 { \"10/16/1990\" \"10/19/2018\" \"20161215\" \"2000-11-12\" } Mapping dummyMapping input dummyValue1 as x , dummyValue2 as y output dummyOutput as op { op . result1 = dayDifference ( x . a , y . p , \"MM/dd/yyyy\" ) op . result2 = dayDifference ( x . b , y . q , \"MM/dd/yyyy\" ) op . result3 = dayDifference ( x . b , y . p , \"MM/dd/yyyy\" ) op . result4 = dayDifference ( x . a , y . q , \"MM/dd/yyyy\" ) op . result5 = dayDifference ( x . c , y . r , \"yyyyMMdd\" ) op . result6 = dayDifference ( x . d , y . s , \"yyyy-MM-dd\" ) } End end Flow mappingFlow { Start dummyMapping { transition { true ? end : end } } end {} } Example Output \u00b6 { \"result1\": 0, \"result2\": 3, \"result3\": -10227, \"result4\": 10230, \"result5\": 6, \"result6\": 10 }","title":"DayDifference"},{"location":"functions/dayDifference/#syntax","text":"dayDifference(input1, input2, format) input1 : Value of Date form which you want to subtract. input2 : Value of Date to be subtracted. format : Format can be any input from the following pre defined formats but both the inputs need to be in same format.","title":"Syntax"},{"location":"functions/dayDifference/#formats","text":"MM/dd/yyyy yyyyMMdd yyyy-MM-dd","title":"Formats"},{"location":"functions/dayDifference/#example-flow","text":"Schema dummy1 { string a string b string c string d } Schema dummy2 { string p string q string r string s } Schema dummyOutput { number result1 number result2 number result3 number result4 number result5 number result6 } value dummyValue1 -> dummy1 { \"10/16/1990\" \"10/16/2018\" \"20161209\" \"2000-11-2\" } value dummyValue2 -> dummy2 { \"10/16/1990\" \"10/19/2018\" \"20161215\" \"2000-11-12\" } Mapping dummyMapping input dummyValue1 as x , dummyValue2 as y output dummyOutput as op { op . result1 = dayDifference ( x . a , y . p , \"MM/dd/yyyy\" ) op . result2 = dayDifference ( x . b , y . q , \"MM/dd/yyyy\" ) op . result3 = dayDifference ( x . b , y . p , \"MM/dd/yyyy\" ) op . result4 = dayDifference ( x . a , y . q , \"MM/dd/yyyy\" ) op . result5 = dayDifference ( x . c , y . r , \"yyyyMMdd\" ) op . result6 = dayDifference ( x . d , y . s , \"yyyy-MM-dd\" ) } End end Flow mappingFlow { Start dummyMapping { transition { true ? end : end } } end {} }","title":"Example Flow"},{"location":"functions/dayDifference/#example-output","text":"{ \"result1\": 0, \"result2\": 3, \"result3\": -10227, \"result4\": 10230, \"result5\": 6, \"result6\": 10 }","title":"Example Output"},{"location":"functions/dedup/","text":"This function builds a new list dropping duplicates except the first occurrence from a given list. It has an optional key parameter to specify the attribute to be used to make comparison from each element in list. Syntax \u00b6 deduplicatedArray = dedup(array) deduplicatedArray = dedup(array, schemaVariable) Inputs \u00b6 array : a reference to an array. schemaVariable : object\u2019s attribute to be used for comparison. Output \u00b6 deduplicatedArray : array after dropping duplicates except the first occurrence based on the key schemaVariable if present. Example flow \u00b6 Schema companyData { employees [ number id string name string city boolean isPermanent ] } value employeeData -> companyData { employees [ { 321 \"Bhavin\" \"San diego\" true } { 321 \"Bhavin\" \"San diego\" true } { 345 \"Alex\" \"San diego\" false } { 456 \"Bhavin\" \"New York\" false } { 456 \"Alex\" \"San diego\" true } ] } Schema ResultSchema { dedupByName -> companyData dedupByEmployee -> companyData } Mapping dedupMapping input employeeData as empData output ResultSchema { ResultSchema.dedupByName.employees = dedup(empData.employees, name) ResultSchema.dedupByEmployee.employees = dedup(empData.employees) } Flow dedup { Start dedupMapping { } } Output for Example Flow \u00b6 { \"dedupByName\": { \"employees\": [ { \"id\": 321, \"name\": \"Bhavin\", \"city\": \"San diego\", \"isPermanent\": true }, { \"id\": 345, \"name\": \"Alex\", \"city\": \"San diego\", \"isPermanent\": false } ] }, \"dedupByEmployee\": { \"employees\": [ { \"id\": 321, \"name\": \"Bhavin\", \"city\": \"San diego\", \"isPermanent\": true }, { \"id\": 345, \"name\": \"Alex\", \"city\": \"San diego\", \"isPermanent\": false }, { \"id\": 456, \"name\": \"Bhavin\", \"city\": \"New York\", \"isPermanent\": false }, { \"id\": 456, \"name\": \"Alex\", \"city\": \"San diego\", \"isPermanent\": true } ] } } Explanation \u00b6 The context of the variable name in the example is the array, which is empData.employees . (You don't have to specify the whole path i.e empData.employees.name to dedup using the name attribute for comparison). In order to dedup the array on employee objects, We do not need to pass any parameter for schemaVariable attribute, by default the elements of the passed array are compared.","title":"Dedup"},{"location":"functions/dedup/#syntax","text":"deduplicatedArray = dedup(array) deduplicatedArray = dedup(array, schemaVariable)","title":"Syntax"},{"location":"functions/dedup/#inputs","text":"array : a reference to an array. schemaVariable : object\u2019s attribute to be used for comparison.","title":"Inputs"},{"location":"functions/dedup/#output","text":"deduplicatedArray : array after dropping duplicates except the first occurrence based on the key schemaVariable if present.","title":"Output"},{"location":"functions/dedup/#example-flow","text":"Schema companyData { employees [ number id string name string city boolean isPermanent ] } value employeeData -> companyData { employees [ { 321 \"Bhavin\" \"San diego\" true } { 321 \"Bhavin\" \"San diego\" true } { 345 \"Alex\" \"San diego\" false } { 456 \"Bhavin\" \"New York\" false } { 456 \"Alex\" \"San diego\" true } ] } Schema ResultSchema { dedupByName -> companyData dedupByEmployee -> companyData } Mapping dedupMapping input employeeData as empData output ResultSchema { ResultSchema.dedupByName.employees = dedup(empData.employees, name) ResultSchema.dedupByEmployee.employees = dedup(empData.employees) } Flow dedup { Start dedupMapping { } }","title":"Example flow"},{"location":"functions/dedup/#output-for-example-flow","text":"{ \"dedupByName\": { \"employees\": [ { \"id\": 321, \"name\": \"Bhavin\", \"city\": \"San diego\", \"isPermanent\": true }, { \"id\": 345, \"name\": \"Alex\", \"city\": \"San diego\", \"isPermanent\": false } ] }, \"dedupByEmployee\": { \"employees\": [ { \"id\": 321, \"name\": \"Bhavin\", \"city\": \"San diego\", \"isPermanent\": true }, { \"id\": 345, \"name\": \"Alex\", \"city\": \"San diego\", \"isPermanent\": false }, { \"id\": 456, \"name\": \"Bhavin\", \"city\": \"New York\", \"isPermanent\": false }, { \"id\": 456, \"name\": \"Alex\", \"city\": \"San diego\", \"isPermanent\": true } ] } }","title":"Output for Example Flow"},{"location":"functions/dedup/#explanation","text":"The context of the variable name in the example is the array, which is empData.employees . (You don't have to specify the whole path i.e empData.employees.name to dedup using the name attribute for comparison). In order to dedup the array on employee objects, We do not need to pass any parameter for schemaVariable attribute, by default the elements of the passed array are compared.","title":"Explanation"},{"location":"functions/extract/","text":"The extract function extracts a substring from string, part of number from a number and range of elements from an array. Syntax \u00b6 output = extract(expression, range) Inputs \u00b6 expression : a reference to a variable or any [[expression|Expressions]]. range : denoted by x..y where x and y are optional and integers. Default value of x = 0 Default value of y = length of value of expression Output \u00b6 output : string, number or array depending on input. Example flow \u00b6 Schema dummy { string string1 string nullstring number number1 arrayinput [ string key ] jsonObject { string jfield } boolean flag } Schema dummyOutput { string result1 string result2 string result3 string result4 string result5 string result6 string result7 string result8 string result9 string result10 string result11 string result12 string result13 string result14 string result15 string result16 string result17 number result18 number result19 number result20 arrayoutput1 [ string key ] arrayoutput2 [ string key ] arrayoutput3 [ string key ] arrayoutput4 [ string key ] resultJsonObject { string jfield } string resultJson string resultflag string invalidRange1 } value dummyValue1 -> dummy { \"hello\" $ { null } 675575757 arrayinput [ { \"field1\" } { \"field2\" } { \"field3\" } { \"field4\" } ] jsonObject { \"jsonField1\" } true } Mapping dummyMapping input dummyValue1 as x output dummyOutput as op { op . result1 = extract ( x . nullstring , 5..9 ) op . result2 = extract ( x . nullstring , ..) op . result3 = extract ( x . nullstring , 1. .) op . result4 = extract ( x . nullstring , . .4 ) op . result5 = extract ( x . string1 , 0..2 ) op . result6 = extract ( x . string1 , 5..9 ) op . result7 = extract ( x . string1 , 5. .) op . result8 = extract ( x . string1 , 1. .) op . result9 = extract ( x . string1 , 9. .) op . result10 = extract ( x . string1 , . .2 ) op . result11 = extract ( x . string1 , . .5 ) op . result12 = extract ( x . string1 , ..) op . result13 = extract ( x . string1 , 0..0 ) op . result14 = extract ( x . string1 , 5..5 ) op . result15 = extract ( x . number1 , 5..9 ) op . result16 = extract ( x . number1 , 0..5 ) op . result17 = extract ( x . number1 , ..) op . result18 = extract ( x . number1 , . .5 ) op . result19 = extract ( x . number1 , 3. .) op . result20 = extract ( x . number1 , 3..30 ) op . arrayoutput1 = extract ( x . arrayinput , 1..2 ) op . arrayoutput2 = extract ( x . arrayinput , . .3 ) op . arrayoutput3 = extract ( x . arrayinput , 2. .) op . arrayoutput4 = extract ( x . arrayinput , ..) op . resultJsonObject = extract ( x . jsonObject , ..) op . resultJson = extract ( x . jsonObject , ..) op . resultflag = extract ( x . flag , 1..2 ) op . invalidRange1 = extract ( x . string1 , hivd .. fwfwedsf ) } Flow mappingFlow { Start dummyMapping {} } Output for Example Flow \u00b6 { \"result1\": null, \"result2\": null, \"result3\": null, \"result4\": null, \"result5\": \"he\", \"result6\": null, \"result7\": \"\", \"result8\": \"ello\", \"result9\": null, \"result10\": \"he\", \"result11\": \"hello\", \"result12\": \"hello\", \"result13\": \"hello\", \"result14\": \"\", \"result15\": \"5757\", \"result16\": \"67557\", \"result17\": \"675575757\", \"result18\": 67557, \"result19\": 575757, \"result20\": null, \"arrayoutput1\": [ { \"key\": \"field2\" } ], \"arrayoutput2\": [ { \"key\": \"field1\" }, { \"key\": \"field2\" }, { \"key\": \"field3\" } ], \"arrayoutput3\": [ { \"key\": \"field3\" }, { \"key\": \"field4\" } ], \"arrayoutput4\": [ { \"key\": \"field1\" }, { \"key\": \"field2\" }, { \"key\": \"field3\" }, { \"key\": \"field4\" } ], \"resultJsonObject\": { \"jfield\": null }, \"resultJson\": null, \"resultflag\": null, \"invalidRange1\": \"hello\" }","title":"Extract"},{"location":"functions/extract/#syntax","text":"output = extract(expression, range)","title":"Syntax"},{"location":"functions/extract/#inputs","text":"expression : a reference to a variable or any [[expression|Expressions]]. range : denoted by x..y where x and y are optional and integers. Default value of x = 0 Default value of y = length of value of expression","title":"Inputs"},{"location":"functions/extract/#output","text":"output : string, number or array depending on input.","title":"Output"},{"location":"functions/extract/#example-flow","text":"Schema dummy { string string1 string nullstring number number1 arrayinput [ string key ] jsonObject { string jfield } boolean flag } Schema dummyOutput { string result1 string result2 string result3 string result4 string result5 string result6 string result7 string result8 string result9 string result10 string result11 string result12 string result13 string result14 string result15 string result16 string result17 number result18 number result19 number result20 arrayoutput1 [ string key ] arrayoutput2 [ string key ] arrayoutput3 [ string key ] arrayoutput4 [ string key ] resultJsonObject { string jfield } string resultJson string resultflag string invalidRange1 } value dummyValue1 -> dummy { \"hello\" $ { null } 675575757 arrayinput [ { \"field1\" } { \"field2\" } { \"field3\" } { \"field4\" } ] jsonObject { \"jsonField1\" } true } Mapping dummyMapping input dummyValue1 as x output dummyOutput as op { op . result1 = extract ( x . nullstring , 5..9 ) op . result2 = extract ( x . nullstring , ..) op . result3 = extract ( x . nullstring , 1. .) op . result4 = extract ( x . nullstring , . .4 ) op . result5 = extract ( x . string1 , 0..2 ) op . result6 = extract ( x . string1 , 5..9 ) op . result7 = extract ( x . string1 , 5. .) op . result8 = extract ( x . string1 , 1. .) op . result9 = extract ( x . string1 , 9. .) op . result10 = extract ( x . string1 , . .2 ) op . result11 = extract ( x . string1 , . .5 ) op . result12 = extract ( x . string1 , ..) op . result13 = extract ( x . string1 , 0..0 ) op . result14 = extract ( x . string1 , 5..5 ) op . result15 = extract ( x . number1 , 5..9 ) op . result16 = extract ( x . number1 , 0..5 ) op . result17 = extract ( x . number1 , ..) op . result18 = extract ( x . number1 , . .5 ) op . result19 = extract ( x . number1 , 3. .) op . result20 = extract ( x . number1 , 3..30 ) op . arrayoutput1 = extract ( x . arrayinput , 1..2 ) op . arrayoutput2 = extract ( x . arrayinput , . .3 ) op . arrayoutput3 = extract ( x . arrayinput , 2. .) op . arrayoutput4 = extract ( x . arrayinput , ..) op . resultJsonObject = extract ( x . jsonObject , ..) op . resultJson = extract ( x . jsonObject , ..) op . resultflag = extract ( x . flag , 1..2 ) op . invalidRange1 = extract ( x . string1 , hivd .. fwfwedsf ) } Flow mappingFlow { Start dummyMapping {} }","title":"Example flow"},{"location":"functions/extract/#output-for-example-flow","text":"{ \"result1\": null, \"result2\": null, \"result3\": null, \"result4\": null, \"result5\": \"he\", \"result6\": null, \"result7\": \"\", \"result8\": \"ello\", \"result9\": null, \"result10\": \"he\", \"result11\": \"hello\", \"result12\": \"hello\", \"result13\": \"hello\", \"result14\": \"\", \"result15\": \"5757\", \"result16\": \"67557\", \"result17\": \"675575757\", \"result18\": 67557, \"result19\": 575757, \"result20\": null, \"arrayoutput1\": [ { \"key\": \"field2\" } ], \"arrayoutput2\": [ { \"key\": \"field1\" }, { \"key\": \"field2\" }, { \"key\": \"field3\" } ], \"arrayoutput3\": [ { \"key\": \"field3\" }, { \"key\": \"field4\" } ], \"arrayoutput4\": [ { \"key\": \"field1\" }, { \"key\": \"field2\" }, { \"key\": \"field3\" }, { \"key\": \"field4\" } ], \"resultJsonObject\": { \"jfield\": null }, \"resultJson\": null, \"resultflag\": null, \"invalidRange1\": \"hello\" }","title":"Output for Example Flow"},{"location":"functions/filter/","text":"The filter function filters the objects from an array based on some condition. Syntax \u00b6 filteredArray = filter(array, booleanExpression) Inputs \u00b6 array : a reference to an array. booleanExpression : conditional expression to filter the objects in the array. Output \u00b6 filteredArray : filtered array based on the condition. Example flow \u00b6 Schema w2Schema { w2 [ string employerName number wages ] } value income -> w2Schema { w2 [ { \"Intuit, Inc. 105000 } { \" Uber 10000 } ] } Schema thresholdSchema { number wages } value threshold -> thresholdSchema { 100000 } Mapping finalMapping input income , threshold output w2Schema as output { output . w2 = filter ( income . w2 , employerName == \"Intuit, Inc.\" && wages > :: threshold . wages ) } Flow filterFlow { Start finalMapping { } } Output for Example Flow \u00b6 { w2 : [{ employerName : \"Intuit, Inc.\", wages : 105000 } } Explanation \u00b6 The condition is employerName == \"Intuit, Inc.\" && wages > ::threshold.wages . The first part of the condition says employerName == \"Intuit, Inc.\" . The context of the variable employerName here is the array, which is income.w2 . (You don't have to specify the whole path i.e income.w2.employerName to filter the w2s). The second part of the condition says wages > ::threshold.wages\" . The variable wages here is within the context of w2 but if you want to refer something which is outside the scope of w2, you need to refer it with a global scope operator ::","title":"Filter"},{"location":"functions/filter/#syntax","text":"filteredArray = filter(array, booleanExpression)","title":"Syntax"},{"location":"functions/filter/#inputs","text":"array : a reference to an array. booleanExpression : conditional expression to filter the objects in the array.","title":"Inputs"},{"location":"functions/filter/#output","text":"filteredArray : filtered array based on the condition.","title":"Output"},{"location":"functions/filter/#example-flow","text":"Schema w2Schema { w2 [ string employerName number wages ] } value income -> w2Schema { w2 [ { \"Intuit, Inc. 105000 } { \" Uber 10000 } ] } Schema thresholdSchema { number wages } value threshold -> thresholdSchema { 100000 } Mapping finalMapping input income , threshold output w2Schema as output { output . w2 = filter ( income . w2 , employerName == \"Intuit, Inc.\" && wages > :: threshold . wages ) } Flow filterFlow { Start finalMapping { } }","title":"Example flow"},{"location":"functions/filter/#output-for-example-flow","text":"{ w2 : [{ employerName : \"Intuit, Inc.\", wages : 105000 } }","title":"Output for Example Flow"},{"location":"functions/filter/#explanation","text":"The condition is employerName == \"Intuit, Inc.\" && wages > ::threshold.wages . The first part of the condition says employerName == \"Intuit, Inc.\" . The context of the variable employerName here is the array, which is income.w2 . (You don't have to specify the whole path i.e income.w2.employerName to filter the w2s). The second part of the condition says wages > ::threshold.wages\" . The variable wages here is within the context of w2 but if you want to refer something which is outside the scope of w2, you need to refer it with a global scope operator ::","title":"Explanation"},{"location":"functions/findFirst/","text":"The findFirst function finds the first object from an array based on some condition. Syntax \u00b6 firstValFound = findFirst ( array , booleanExpression ) Inputs \u00b6 array : a reference to an array. booleanExpression : conditional expression to find an object in the array. Output \u00b6 firstValFound : the first value in the array that caused the boolean expression to evaluate to true. Example flow \u00b6 Schema w2Schema { w2 [ string employerName number wages ] } Schema Outcome { string employerName number wages } value income -> w2Schema { w2 [ { \"Intuit, Inc. 105000 } { \" Uber 10000 } ] } Schema thresholdSchema { number wages } value threshold -> thresholdSchema { 100000 } Mapping finalMapping input income , threshold output Outcome as output { output = findFirst ( income . w2 , employerName == \"Intuit, Inc.\" && wages > :: threshold . wages ) } Flow filterFlow { Start finalMapping { } } Output for Example Flow \u00b6 { employerName : \"Intuit, Inc.\", wages : 105000 } Explanation \u00b6 The condition is employerName == \"Intuit, Inc.\" && wages > ::threshold.wages . The first part of the condition says employerName == \"Intuit, Inc.\" . The context of the variable employerName here is the array, which is income.w2 . (You don't have to specify the whole path i.e income.w2.employerName to filter the w2s). The second part of the condition says wages > ::threshold.wages\" . The variable wages here is within the context of w2 but if you want to refer something which is outside the scope of w2, you need to refer it with a global scope operator ::","title":"FindFirst"},{"location":"functions/findFirst/#syntax","text":"firstValFound = findFirst ( array , booleanExpression )","title":"Syntax"},{"location":"functions/findFirst/#inputs","text":"array : a reference to an array. booleanExpression : conditional expression to find an object in the array.","title":"Inputs"},{"location":"functions/findFirst/#output","text":"firstValFound : the first value in the array that caused the boolean expression to evaluate to true.","title":"Output"},{"location":"functions/findFirst/#example-flow","text":"Schema w2Schema { w2 [ string employerName number wages ] } Schema Outcome { string employerName number wages } value income -> w2Schema { w2 [ { \"Intuit, Inc. 105000 } { \" Uber 10000 } ] } Schema thresholdSchema { number wages } value threshold -> thresholdSchema { 100000 } Mapping finalMapping input income , threshold output Outcome as output { output = findFirst ( income . w2 , employerName == \"Intuit, Inc.\" && wages > :: threshold . wages ) } Flow filterFlow { Start finalMapping { } }","title":"Example flow"},{"location":"functions/findFirst/#output-for-example-flow","text":"{ employerName : \"Intuit, Inc.\", wages : 105000 }","title":"Output for Example Flow"},{"location":"functions/findFirst/#explanation","text":"The condition is employerName == \"Intuit, Inc.\" && wages > ::threshold.wages . The first part of the condition says employerName == \"Intuit, Inc.\" . The context of the variable employerName here is the array, which is income.w2 . (You don't have to specify the whole path i.e income.w2.employerName to filter the w2s). The second part of the condition says wages > ::threshold.wages\" . The variable wages here is within the context of w2 but if you want to refer something which is outside the scope of w2, you need to refer it with a global scope operator ::","title":"Explanation"},{"location":"functions/join/","text":"The join function joins an array based on the key with a delimiter and last_delimiter. Syntax \u00b6 output = join(expression,key,delimiter,last_delimiter) Inputs \u00b6 expression : a reference to a variable or any [[expression|Expressions]]. This variable needs to be a json array or a string array key : This is optional. It represents the key if the expression is a json array. Skip this parameter in case of String array. delimiter : The delimiter to join on. last_delimiter : The last delimiter. Output \u00b6 output : The joined string. Example flow \u00b6 Schema dependentsSchema { spouse { string name } children [ string name ] } Schema joinOutputSchema { string dependentsText } value dependents -> dependentsSchema { spouse { \"Foo\" } children [ { \"A\" } { \"B\" } { \"C\" } ] } Mapping finalMapping input dependents output joinOutputSchema { joinOutputSchema . dependentsText = join ( dependents . children , name , \",\" , \"and\" ) } Output for Example Flow \u00b6 { \"dependentsText\" : \"A, B and C\" }","title":"Join"},{"location":"functions/join/#syntax","text":"output = join(expression,key,delimiter,last_delimiter)","title":"Syntax"},{"location":"functions/join/#inputs","text":"expression : a reference to a variable or any [[expression|Expressions]]. This variable needs to be a json array or a string array key : This is optional. It represents the key if the expression is a json array. Skip this parameter in case of String array. delimiter : The delimiter to join on. last_delimiter : The last delimiter.","title":"Inputs"},{"location":"functions/join/#output","text":"output : The joined string.","title":"Output"},{"location":"functions/join/#example-flow","text":"Schema dependentsSchema { spouse { string name } children [ string name ] } Schema joinOutputSchema { string dependentsText } value dependents -> dependentsSchema { spouse { \"Foo\" } children [ { \"A\" } { \"B\" } { \"C\" } ] } Mapping finalMapping input dependents output joinOutputSchema { joinOutputSchema . dependentsText = join ( dependents . children , name , \",\" , \"and\" ) }","title":"Example flow"},{"location":"functions/join/#output-for-example-flow","text":"{ \"dependentsText\" : \"A, B and C\" }","title":"Output for Example Flow"},{"location":"functions/json/","text":"The json function converts the variable representing TSI xml data to a json. Syntax \u00b6 output = json(expression) Inputs \u00b6 expression : a reference to a TSI variable with xml data. Output \u00b6 output : a json representation of the TSI data. Example flow \u00b6 Schema outputSchema { op [ string HCY string HLY ] } Schema tsiSchema { S2016US1040PER { form FONLINE { field HCY field HLY field PRODTYPE } } } Service tsiService as getTsi input requestContext output tsiSchema {} Mapping finalMapping input tsiSchema output outputSchema { outputSchema.op = json(S2016US1040PER.FONLINE) } Flow tsiFlow { Start getTsi { transition { finalMapping{} } } finalMapping{} } Output for Example Flow \u00b6 { op : { HCLX : \"b\", HCLY : \"a\" } }","title":"Json"},{"location":"functions/json/#syntax","text":"output = json(expression)","title":"Syntax"},{"location":"functions/json/#inputs","text":"expression : a reference to a TSI variable with xml data.","title":"Inputs"},{"location":"functions/json/#output","text":"output : a json representation of the TSI data.","title":"Output"},{"location":"functions/json/#example-flow","text":"Schema outputSchema { op [ string HCY string HLY ] } Schema tsiSchema { S2016US1040PER { form FONLINE { field HCY field HLY field PRODTYPE } } } Service tsiService as getTsi input requestContext output tsiSchema {} Mapping finalMapping input tsiSchema output outputSchema { outputSchema.op = json(S2016US1040PER.FONLINE) } Flow tsiFlow { Start getTsi { transition { finalMapping{} } } finalMapping{} }","title":"Example flow"},{"location":"functions/json/#output-for-example-flow","text":"{ op : { HCLX : \"b\", HCLY : \"a\" } }","title":"Output for Example Flow"},{"location":"functions/length/","text":"The length function gives the length of an expression. The expression is mostly a variable Syntax \u00b6 output = length(expression) Inputs \u00b6 expression : a reference to a variable or any [[expression|Expressions]]. Output \u00b6 output : a numerical value which represents the length of the input expression. Example flow \u00b6 Schema dummy { a [ string b ] } Schema dummyOutput { number x } value dummyValue -> dummy { a [{ \"x\" }{ \"y\" }] } Mapping dummyMapping input dummyValue as p output dummyOutput as q { q . x = length ( p . a ) } Output for Example Flow \u00b6 { x : 2 }","title":"Length"},{"location":"functions/length/#syntax","text":"output = length(expression)","title":"Syntax"},{"location":"functions/length/#inputs","text":"expression : a reference to a variable or any [[expression|Expressions]].","title":"Inputs"},{"location":"functions/length/#output","text":"output : a numerical value which represents the length of the input expression.","title":"Output"},{"location":"functions/length/#example-flow","text":"Schema dummy { a [ string b ] } Schema dummyOutput { number x } value dummyValue -> dummy { a [{ \"x\" }{ \"y\" }] } Mapping dummyMapping input dummyValue as p output dummyOutput as q { q . x = length ( p . a ) }","title":"Example flow"},{"location":"functions/length/#output-for-example-flow","text":"{ x : 2 }","title":"Output for Example Flow"},{"location":"functions/map/","text":"The map function is used to perform one to one mapping on elements from an array to a result array, after some processing or as is. Syntax \u00b6 resultArray = map ( array { Range } -> { result_attr_i1 = array_attr_k1 result_attr_i2 = array_attr_k2 }) Inputs \u00b6 array : a reference to an array. Range :This is an optional input giving a sequence of integers. Please refer [[Range]] for the syntax. Map function will only execute on elements in the input array at given sequence of indices. Output \u00b6 resultArray : Array returned after the mapping. Example flow \u00b6 Schema inputSchema { string a string b number c boolean d object { string a string b } array [ string a string b string c number d ] } value inputValue -> inputSchema { \"A\" \"B\" 1 true object { \"a\" \"b\" } array [ { \"a\" \"a\" \"c\" 100 } { \"a\" \"b\" \"c\" 10 } { \"a\" \"b\" \"c\" 1 } { \"a\" \"b\" \"c\" 0 } ] } Schema outputSchema { mapArray [ string name string desc string amount ] mapObject { string name string value } mapArrayWithRange [ string name string desc string amount ] } Mapping outPutMapping input inputValue as inputValue output outputSchema { outputSchema.mapArray = map(inputValue.array->{ name = a desc = b amount = d }) outputSchema.mapArrayWithRange = map(inputValue.array{0..1}->{ name = a desc = b amount = d }) outputSchema.mapObject = map(inputValue.object->{ name = a value = b }) } Flow mapFlow { Start outPutMapping{} } Output: { \"mapArray\": [ { \"name\": \"a\", \"desc\": \"a\", \"amount\": 100 }, { \"name\": \"a\", \"desc\": \"b\", \"amount\": 10 }, { \"name\": \"a\", \"desc\": \"b\", \"amount\": 1 }, { \"name\": \"a\", \"desc\": \"b\", \"amount\": 0 } ], \"mapObject\": { \"name\": \"a\", \"value\": \"b\" } \"mapArrayWithRange\": [ { \"name\": \"a\", \"desc\": \"a\", \"amount\": 100 }, { \"name\": \"a\", \"desc\": \"b\", \"amount\": 10 } ] }","title":"Map"},{"location":"functions/map/#syntax","text":"resultArray = map ( array { Range } -> { result_attr_i1 = array_attr_k1 result_attr_i2 = array_attr_k2 })","title":"Syntax"},{"location":"functions/map/#inputs","text":"array : a reference to an array. Range :This is an optional input giving a sequence of integers. Please refer [[Range]] for the syntax. Map function will only execute on elements in the input array at given sequence of indices.","title":"Inputs"},{"location":"functions/map/#output","text":"resultArray : Array returned after the mapping.","title":"Output"},{"location":"functions/map/#example-flow","text":"Schema inputSchema { string a string b number c boolean d object { string a string b } array [ string a string b string c number d ] } value inputValue -> inputSchema { \"A\" \"B\" 1 true object { \"a\" \"b\" } array [ { \"a\" \"a\" \"c\" 100 } { \"a\" \"b\" \"c\" 10 } { \"a\" \"b\" \"c\" 1 } { \"a\" \"b\" \"c\" 0 } ] } Schema outputSchema { mapArray [ string name string desc string amount ] mapObject { string name string value } mapArrayWithRange [ string name string desc string amount ] } Mapping outPutMapping input inputValue as inputValue output outputSchema { outputSchema.mapArray = map(inputValue.array->{ name = a desc = b amount = d }) outputSchema.mapArrayWithRange = map(inputValue.array{0..1}->{ name = a desc = b amount = d }) outputSchema.mapObject = map(inputValue.object->{ name = a value = b }) } Flow mapFlow { Start outPutMapping{} } Output: { \"mapArray\": [ { \"name\": \"a\", \"desc\": \"a\", \"amount\": 100 }, { \"name\": \"a\", \"desc\": \"b\", \"amount\": 10 }, { \"name\": \"a\", \"desc\": \"b\", \"amount\": 1 }, { \"name\": \"a\", \"desc\": \"b\", \"amount\": 0 } ], \"mapObject\": { \"name\": \"a\", \"value\": \"b\" } \"mapArrayWithRange\": [ { \"name\": \"a\", \"desc\": \"a\", \"amount\": 100 }, { \"name\": \"a\", \"desc\": \"b\", \"amount\": 10 } ] }","title":"Example flow"},{"location":"functions/pickFirst/","text":"The pickFirst function picks the first object from various provided objects based on some condition. Syntax \u00b6 firstValuePicked = pickFirst ( object1 , object2 ,... -> booleanExpression ) Inputs \u00b6 objects : comma separated 1 or more objects booleanExpression : conditional expression that applies to current object. (eg: it > 100) Output \u00b6 firstValuePicked : the first object value that caused the boolean expression to evaluate to true. Example flow \u00b6 Schema triageSchema { coreProfile { number taxYear } } Schema requestContext { number taxYear } value triageValue -> triageSchema { coreProfile { 1980 } } value requestContextValue -> requestContext { 2015 } Schema result { number taxYear } Mapping finalMapping input triageValue , requestContextValue output result { result . taxYear = pickFirst ( triageValue . coreProfile . taxYear , requestContextValue . taxYear -> it > 2000 ) } Flow filterFlow { Start finalMapping { } } Output for Example Flow \u00b6 { taxYear : 2015 }","title":"PickFirst"},{"location":"functions/pickFirst/#syntax","text":"firstValuePicked = pickFirst ( object1 , object2 ,... -> booleanExpression )","title":"Syntax"},{"location":"functions/pickFirst/#inputs","text":"objects : comma separated 1 or more objects booleanExpression : conditional expression that applies to current object. (eg: it > 100)","title":"Inputs"},{"location":"functions/pickFirst/#output","text":"firstValuePicked : the first object value that caused the boolean expression to evaluate to true.","title":"Output"},{"location":"functions/pickFirst/#example-flow","text":"Schema triageSchema { coreProfile { number taxYear } } Schema requestContext { number taxYear } value triageValue -> triageSchema { coreProfile { 1980 } } value requestContextValue -> requestContext { 2015 } Schema result { number taxYear } Mapping finalMapping input triageValue , requestContextValue output result { result . taxYear = pickFirst ( triageValue . coreProfile . taxYear , requestContextValue . taxYear -> it > 2000 ) } Flow filterFlow { Start finalMapping { } }","title":"Example flow"},{"location":"functions/pickFirst/#output-for-example-flow","text":"{ taxYear : 2015 }","title":"Output for Example Flow"},{"location":"functions/remove/","text":"The remove function essentially works as an inverse to the filter function. It takes an array and a boolean expression and returns a filtered array containing only the elements that don't match the expression. See [[filter]] for info on how the function behaves. \u00b6","title":"Remove"},{"location":"functions/remove/#see-filter-for-info-on-how-the-function-behaves","text":"","title":"See [[filter]] for info on how the function behaves."},{"location":"functions/shuffle/","text":"This function builds a new shuffled array from a given array. Shuffled array means the order of elements in the array is changed in random manner. It works only on collection. Doesn't work on primitive types like String, Int etc Syntax \u00b6 shuffledArray = shuffle(array) Inputs \u00b6 array : a reference to an array. Output \u00b6 shuffledArray : shuffled array Example flow \u00b6 Schema companyData { employees [ number id string name string city ] } value employeeData -> companyData { employees [ { 321 \"John\" \"San diego\" } { 534 \"Alex\" \"New York\" } { 456 \"Sam\" \"Seattle\" } ] numberArray [ 1 2 3 4 ] shuffleString: \"abcd\" shuffleNumber: 1234 shuffleNull: ${null} } Mapping sortMapping input employeeData as empData output companyData as resultSchema { resultSchema.employees = shuffle(empData.employees) resultSchema.numberArray = shuffle(empData.numberArray) resultSchema.shuffleString = shuffle(empData.shuffleString) resultSchema.shuffleNumber = shuffle(empData.shuffleNumber) resultSchema.shuffleNull = shuffle(empData.shuffleNull) } Flow Shuffle { Start shuffleMapping {} } Output for Example Flow \u00b6 { \"employees\": [ { \"id\": 534, \"name\": \"Alex\", \"city\": \"New York\" }, { \"id\": 321, \"name\": \"John\", \"city\": \"San diego\" }, { \"id\": 456, \"name\": \"Sam\", \"city\": \"Seattle\" } ], \"numberArray\": [ 4, 1, 3, 2 ], \"shuffleString\": \"abcd\", \"shuffleNumber\": 1234, \"shuffleNull\": null }","title":"Shuffle"},{"location":"functions/shuffle/#syntax","text":"shuffledArray = shuffle(array)","title":"Syntax"},{"location":"functions/shuffle/#inputs","text":"array : a reference to an array.","title":"Inputs"},{"location":"functions/shuffle/#output","text":"shuffledArray : shuffled array","title":"Output"},{"location":"functions/shuffle/#example-flow","text":"Schema companyData { employees [ number id string name string city ] } value employeeData -> companyData { employees [ { 321 \"John\" \"San diego\" } { 534 \"Alex\" \"New York\" } { 456 \"Sam\" \"Seattle\" } ] numberArray [ 1 2 3 4 ] shuffleString: \"abcd\" shuffleNumber: 1234 shuffleNull: ${null} } Mapping sortMapping input employeeData as empData output companyData as resultSchema { resultSchema.employees = shuffle(empData.employees) resultSchema.numberArray = shuffle(empData.numberArray) resultSchema.shuffleString = shuffle(empData.shuffleString) resultSchema.shuffleNumber = shuffle(empData.shuffleNumber) resultSchema.shuffleNull = shuffle(empData.shuffleNull) } Flow Shuffle { Start shuffleMapping {} }","title":"Example flow"},{"location":"functions/shuffle/#output-for-example-flow","text":"{ \"employees\": [ { \"id\": 534, \"name\": \"Alex\", \"city\": \"New York\" }, { \"id\": 321, \"name\": \"John\", \"city\": \"San diego\" }, { \"id\": 456, \"name\": \"Sam\", \"city\": \"Seattle\" } ], \"numberArray\": [ 4, 1, 3, 2 ], \"shuffleString\": \"abcd\", \"shuffleNumber\": 1234, \"shuffleNull\": null }","title":"Output for Example Flow"},{"location":"functions/sort/","text":"This function builds a new sorted list from a given list. It has a key parameter to specify the attribute to be used to make comparison from each element in list. Syntax \u00b6 sortedArray = sort(array, schemaVariable) sortedArray = sort(array, schemaVariable, orderType) Inputs \u00b6 array : a reference to an array. schemaVariable : object\u2019s attribute to be used for comparison. orderType : optional parameter to specify ascending (default value) or descending order Output \u00b6 sortedArray : sorted array based on the orderType . Example flow \u00b6 Schema companyData { employees [ number id string name string city ] } value employeeData -> companyData { employees [ { 321 \"Bhavin\" \"San diego\" } { 534 \"Alex\" \"New York\" } { 456 \"Sam\" \"Seattle\" } ] } Schema ResultSchema { sortById -> companyData reverseSortById -> companyData } Mapping sortMapping input employeeData as empData output ResultSchema { ResultSchema.sortById.employees = sort(empData.employees, id) ResultSchema.reverseSortById.employees = sort(empData.employees, id, descending) } Flow Sort { Start sortMapping { } } Output for Example Flow \u00b6 { \"sortById\": { \"employees\": [ { \"id\": 321, \"name\": \"Bhavin\", \"city\": \"San diego\" }, { \"id\": 456, \"name\": \"Sam\", \"city\": \"Seattle\" }, { \"id\": 534, \"name\": \"Alex\", \"city\": \"New York\" } ] }, \"reverseSortById\": { \"employees\": [ { \"id\": 534, \"name\": \"Alex\", \"city\": \"New York\" }, { \"id\": 456, \"name\": \"Sam\", \"city\": \"Seattle\" }, { \"id\": 321, \"name\": \"Bhavin\", \"city\": \"San diego\" } ] } } Explanation \u00b6 The context of the variable id here is the array, which is empData.employees . (You don't have to specify the whole path i.e empData.employees.id to sort using the id for comparison). In order to sort the array in reverse using the id, The parameter descending is passed. There is no need to pass an ascending parameter as by default the array is sorted in ascending order.","title":"Sort"},{"location":"functions/sort/#syntax","text":"sortedArray = sort(array, schemaVariable) sortedArray = sort(array, schemaVariable, orderType)","title":"Syntax"},{"location":"functions/sort/#inputs","text":"array : a reference to an array. schemaVariable : object\u2019s attribute to be used for comparison. orderType : optional parameter to specify ascending (default value) or descending order","title":"Inputs"},{"location":"functions/sort/#output","text":"sortedArray : sorted array based on the orderType .","title":"Output"},{"location":"functions/sort/#example-flow","text":"Schema companyData { employees [ number id string name string city ] } value employeeData -> companyData { employees [ { 321 \"Bhavin\" \"San diego\" } { 534 \"Alex\" \"New York\" } { 456 \"Sam\" \"Seattle\" } ] } Schema ResultSchema { sortById -> companyData reverseSortById -> companyData } Mapping sortMapping input employeeData as empData output ResultSchema { ResultSchema.sortById.employees = sort(empData.employees, id) ResultSchema.reverseSortById.employees = sort(empData.employees, id, descending) } Flow Sort { Start sortMapping { } }","title":"Example flow"},{"location":"functions/sort/#output-for-example-flow","text":"{ \"sortById\": { \"employees\": [ { \"id\": 321, \"name\": \"Bhavin\", \"city\": \"San diego\" }, { \"id\": 456, \"name\": \"Sam\", \"city\": \"Seattle\" }, { \"id\": 534, \"name\": \"Alex\", \"city\": \"New York\" } ] }, \"reverseSortById\": { \"employees\": [ { \"id\": 534, \"name\": \"Alex\", \"city\": \"New York\" }, { \"id\": 456, \"name\": \"Sam\", \"city\": \"Seattle\" }, { \"id\": 321, \"name\": \"Bhavin\", \"city\": \"San diego\" } ] } }","title":"Output for Example Flow"},{"location":"functions/sort/#explanation","text":"The context of the variable id here is the array, which is empData.employees . (You don't have to specify the whole path i.e empData.employees.id to sort using the id for comparison). In order to sort the array in reverse using the id, The parameter descending is passed. There is no need to pass an ascending parameter as by default the array is sorted in ascending order.","title":"Explanation"},{"location":"functions/split/","text":"The split function splits a string based on the splitter given and saves the result in an array. Syntax \u00b6 output = split(expression, splitter) Inputs \u00b6 expression : a reference to a variable or any [[expression|Expressions]]. splitter : a string or a character based on which you want to split the string Output \u00b6 output : an array of strings resulted from splitting input. Example flow \u00b6 Schema splitWordSchema { splitWord1 [ string word1 ] splitWord2 [ string word1 ] splitWord3 [ string word1 ] splitWord4 [ string word1 ] splitWord5 [ string word1 ] splitWord6 [ string word1 ] } Schema wordSchema { string word1 string word2 string word3 string word4 string wordSplit } value dummyWord -> wordSchema { \"a|b|c\" \"a.b.c\" \"[CS]v1|2C0872A1051D7A42-6000190C600082FB[CE]\" \"null\" } Mapping splitMapping input dummyWord as dummyWord output splitWordSchema { splitWordSchema . splitWord1 = if ( contains ( dummyWord . word1 , \"a\" )) then split ( dummyWord . word1 , \" \\\\ |\" ) else null splitWordSchema . splitWord2 = split ( dummyWord . word2 , \" \\\\ .\" ) splitWordSchema . splitWord3 = split ( dummyWord . word3 , \" \\\\ |\" ) splitWordSchema . splitWord4 = if ( ! contains ( dummyWord . word4 , \"a\" )) then split ( dummyWord . word4 , \" \\\\ |\" ) else null splitWordSchema . splitWord5 = split ( dummyWord . word1 , \" \\\\ .\" ) splitWordSchema . splitWord6 = split ( splitWordSchema . splitWord3 [ 1 ], \" \\\\ [\" ) } Output for Example Flow \u00b6 { \"splitWord1\" : [ \"a\", \"b\", \"c\" ] , \"splitWord2\" : [ \"a\", \"b\", \"c\" ] , \"splitWord3\" : [ \"[CS ] v1 \", \" 2 C0872A1051D7A42 - 6000190 C600082FB [ CE ] \" ], \" splitWord4 \": { \" word1 \": null }, \" splitWord5 \": [ \" a | b | c \" ], \" splitWord6 \": [ \" 2 C0872A1051D7A42 - 6000190 C600082FB \", \" CE ]\" ] }","title":"Split"},{"location":"functions/split/#syntax","text":"output = split(expression, splitter)","title":"Syntax"},{"location":"functions/split/#inputs","text":"expression : a reference to a variable or any [[expression|Expressions]]. splitter : a string or a character based on which you want to split the string","title":"Inputs"},{"location":"functions/split/#output","text":"output : an array of strings resulted from splitting input.","title":"Output"},{"location":"functions/split/#example-flow","text":"Schema splitWordSchema { splitWord1 [ string word1 ] splitWord2 [ string word1 ] splitWord3 [ string word1 ] splitWord4 [ string word1 ] splitWord5 [ string word1 ] splitWord6 [ string word1 ] } Schema wordSchema { string word1 string word2 string word3 string word4 string wordSplit } value dummyWord -> wordSchema { \"a|b|c\" \"a.b.c\" \"[CS]v1|2C0872A1051D7A42-6000190C600082FB[CE]\" \"null\" } Mapping splitMapping input dummyWord as dummyWord output splitWordSchema { splitWordSchema . splitWord1 = if ( contains ( dummyWord . word1 , \"a\" )) then split ( dummyWord . word1 , \" \\\\ |\" ) else null splitWordSchema . splitWord2 = split ( dummyWord . word2 , \" \\\\ .\" ) splitWordSchema . splitWord3 = split ( dummyWord . word3 , \" \\\\ |\" ) splitWordSchema . splitWord4 = if ( ! contains ( dummyWord . word4 , \"a\" )) then split ( dummyWord . word4 , \" \\\\ |\" ) else null splitWordSchema . splitWord5 = split ( dummyWord . word1 , \" \\\\ .\" ) splitWordSchema . splitWord6 = split ( splitWordSchema . splitWord3 [ 1 ], \" \\\\ [\" ) }","title":"Example flow"},{"location":"functions/split/#output-for-example-flow","text":"{ \"splitWord1\" : [ \"a\", \"b\", \"c\" ] , \"splitWord2\" : [ \"a\", \"b\", \"c\" ] , \"splitWord3\" : [ \"[CS ] v1 \", \" 2 C0872A1051D7A42 - 6000190 C600082FB [ CE ] \" ], \" splitWord4 \": { \" word1 \": null }, \" splitWord5 \": [ \" a | b | c \" ], \" splitWord6 \": [ \" 2 C0872A1051D7A42 - 6000190 C600082FB \", \" CE ]\" ] }","title":"Output for Example Flow"}]}